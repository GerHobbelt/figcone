#include <figcone/figcone.h>
#include <figcone/shortmacros.h>
#include <filesystem>
#include <iostream>
#include <map>
#include <vector>

struct NotEmpty {
    template<typename TList>
    void operator()(const TList& list)
    {
        if (!list.empty())
            throw figcone::ValidationError{"can't be empty."};
    }
};

struct PhotoViewerCfg : public figcone::Config {
    PARAM(rootDir, std::filesystem::path)
            .ensure(
                    [](const auto& path)
                    {
                        if (!std::filesystem::exists(path))
                            throw figcone::ValidationError{"a path must exist"};
                    });
    PARAMLIST(supportedFiles, std::vector<std::string>).ensure<NotEmpty>();
    using StringMap = std::map<std::string, std::string>;
    DICT(envVars, StringMap)();
};

int main(void)
{
    try {
        auto cfgReader = figcone::ConfigReader{};
        auto cfg = cfgReader.readYaml<PhotoViewerCfg>(R"(
            rootDir: ~/Photos
            supportedFiles: []
        )");

        std::cout << "Launching PhotoViewer in directory " << cfg.rootDir << std::endl;

        if (!cfg.supportedFiles.empty())
            std::cout << "Supported files:" << std::endl;
        for (const auto& file : cfg.supportedFiles)
            std::cout << "  " << file << std::endl;

        return 0;
    }
    catch (const figcone::ConfigError& e) {
        std::cout << "Config error:" << e.what();
        return 1;
    }
}